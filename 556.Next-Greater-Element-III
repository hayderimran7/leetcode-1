/*
Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.

Example 1:

Input: 12
Output: 21

 

Example 2:

Input: 21
Output: -1
*/

class Solution {
public:
    int nextGreaterElement(int n) {
        string s = to_string(n);
        std::vector<char> num(s.begin(), s.end());
        int i, j;
        for (i = num.size()-1; i > 0; i--) {
            if (num[i-1] < num[i]) break;
        }

        if (i == 0) return -1;

        int x = num[i-1], smallest = i;
        for (j = i+1; j < num.size(); j++) {
            if (num[j] > x && num[j] <= num[smallest]) {
                smallest = j;
            }
        }
        
        swap(num[i-1], num[smallest]);
        sort(num.begin()+i, num.end());
        
        string res = string(num.begin(), num.end());
        auto r = stoll(res);
        return (r > INT_MAX || r <= n) ? -1 : r;
    }
};

class Solution {
public:
    int nextGreaterElement(int n) {
        auto digits = to_string(n);
        next_permutation(begin(digits), end(digits));
        auto res = stoll(digits);
        return (res > INT_MAX || res <= n) ? -1 : res;
    }
};
